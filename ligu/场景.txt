场景一：
	杯赛分小组赛和淘汰赛，所有小组打完生成淘汰赛入围球队。现因线下运营人员现场统计比分错误，导致出线球队不对。需要重新录入小组赛比分。
	涉及到4-5张表数据更新回滚操作，最多一张表统计球员个人数据的可能上千调数据。
	
	传统方案
		在一个服务里，把需要回滚的数据计算出来，放入容器，弄成一个事务（涉及数据比较多，事务大）
			优点：数据一致性，要么全成功，要么全失败。
			缺点：
				用户等待响应时间长。
				事务大，对数据库性能影响。
				服务调用方可能存在超时，有重试机制需要考虑接口的幂等性（分布式-redis实现）
	分布式实现方案：
		服务提供方发送关键信息到MQ，而且提供一个计算需要回滚数据的接口，和个表分批更新的接口
		在另一个服务消费MQ消息并调用计算接口获取数据，切分数据后，调用更新接口。处理结束往redis中存放一个标识。
		
		优点：
			用户响应快，用户请求，直接发送MQ就算完了。在请求成功的function内每个500ms请求下redis标识，查看MQ是否成功消费处理。
			事务切分，小事务降低数据库压力（没成功重试机制），业务异步，微服务响应快，降低超时重试概率。
		缺点：系统的复制程度升高。测试，开发成本等。
		

		mysql 批量更新 考虑sql长度。过长会报错。
			1、replace into 
				原理是先删除再插入
			2、case when 实现
				
			3、循环更新
			
						
			消息会丢失！			


场景二：
	每场赛程开赛前24小时、2小时、5分钟三个时段需要发送消息给改赛程的参赛选手
	方案一（原方案）
		设置一个高频定时任务（一分钟执行一次）去查询数据库；
		缺点：高频查询数据库，造成数据库压力
	
	方案二
		赛程生成或更新是往MQ队列发送一个延时队列（延长到该比赛前24小时），消费此消息完再发送一个消息（延长到开赛前2小时）。。。
		
	方案三（重新实现）
		用job加延时队列的方式，每天执行一次任务把今天需要发送消息的赛程查询出来，发送至MQ。
		在新增和更新时判断是否需要在此时发至MQ还是等待定时任务处理。
			